import "hashes/pedersen/512bit" as pedersenHash;

import "./hand" as getHand;
from "./hand" import HandInfo, CommonCards, RevealCard, compareHand;
import "./verifySignature" as v;

struct Action {
    bool fold;
    u32 commited; // amount of bet
    u32 token; // which token
}

struct Signature {
    field[2] R;
    field S;
    field[2] A;
    u32[8] M0;
    u32[8] M1;
}

struct Player {
    bool seated;

    u32[7] sorted7Cards;
    u32[5] hint;
    HandInfo handinfo;
    Action a;
    Signature s;

    // Relative hand strength
    u32 strength;
    // [0, 9)
    u32 stackRank;
    // winner & choppers (when the players is not losing)
    // If stackRank = 4, then 0, 1, 2, 3 are shorter stacks and 5, 6, 7, 8 are longer stackes
    // if winnerAndChoppers = [0, 0, 16, 5, "", 4, 4, 4, 4]
    //                                ^  ^      ^  ^  ^  ^
    //                             winner|----choppers---|
    // When calculating the win amount,
    // shoterWinnerCoveredPot = if hasShorterWinner {
    //     players[winner].coveredPot)
    // } else {
    //     0
    // }
    // 1. chop0 = (chopper0.coveredPot - players[winner].coveredPot) / 5
    // 2. chop1 = (chopper1.coveredPot - chopper0.coveredPot) / 4
    // winAmount = chop0 + chop1
    u32 shorterWinnerStackIndex; // 2
    bool hasShorterWinner;       // true
    u32[9] winnerAndChoppers;

    u32 coveredPot;
    bool[9] cover; // TODO make use of playerIndexToStackRank
    bool[9] covered;

    u32 winAmount;
}

def hashAction(Action a) -> u32[8] {
    u32[16] mut preimage = [0; 16];
    preimage[0] = a.commited;
    preimage[1] = a.token;

    return pedersenHash(preimage);
}

def verifySignature(Player p) -> bool {
    return !p.seated;
    // || v(p.s.R, p.s.S, p.s.A, p.s.M0, p.s.M1);
}

def comparePlayer(Player a, Player b) -> u32 {
    bool aIn = a.seated && !a.a.fold;
    bool bIn = b.seated && !b.a.fold;

    return if !aIn || !bIn {
        if aIn {
            2
        } else {
            if bIn {
                0
            } else {
                1
            }
        }
    } else {
        compareHand(getHand(a.sorted7Cards, a.hint), getHand(b.sorted7Cards, b.hint))
    };
}

def checkCoverIntegrity(Player[9] players) -> bool {
    for u32 i in 0..9 {
        bool[9] mut cover = [false; 9];
        bool[9] mut covered = [false; 9];
        u32 mut coveredPot = 0;

        for u32 j in 0..9 {
            cover[j] = players[j].a.commited <= players[i].a.commited;
            covered[j] = players[j].a.commited >= players[i].a.commited;

            assert(cover[j] == players[i].cover[j]);
            assert(covered[j] == players[i].covered[j]);

            coveredPot = coveredPot + if cover[j] {
                players[j].a.commited
            } else {
                players[i].a.commited
            };
        }

        assert(coveredPot == players[i].coveredPot);
    }

    return true;
}

def checkWinAmountIntegrity(Player[9] players) -> bool {
    for u32 i in 0..9 {
        u32 mut calculatedWinAmount = 0;

        // Check coverees
        u32 stackRank = players[i].stackRank;


        // Check coverers
        bool mut loseToCoverer = false;
        for u32 j in 0..9 {
            loseToCoverer = loseToCoverer || 
                players[i].covered[j] && players[i].strength < players[j].strength;
        }
        calculatedWinAmount = if loseToCoverer {
            0
        } else {
            calculatedWinAmount
        };

        assert(calculatedWinAmount == players[i].winAmount);
    }

    return true;
}